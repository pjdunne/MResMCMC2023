import numpy as np
import matplotlib.pyplot as plt
    
def auto_covariance(thetas, time_lag):

    """
    
    calculating the auto-covariance of the stochastic processes of the parameter theta

    Argumrnts
    ---------
    theta : the inputed value of the parameter theta generated by the stochastic process
    time_lag : the value of the time-lag of the of the auto-correlation

    Returns
    -------
    auto_cov : the auto-covariance value of the inputed parameters
    
    """

    thetas = np.asarray(thetas)
    n = thetas.shape[0]
    if len((thetas.shape))==1:
        thetas = np.expand_dims(thetas, axis=1)
    auto_cov, m1, m2= np.zeros(thetas.shape[1]), np.zeros(thetas.shape[1]), np.zeros(thetas.shape[1])
    t1 = 0
    assert(t1+time_lag<=n-1)
    while(t1+time_lag<=n-1):
        auto_cov += (thetas[t1]*thetas[t1+time_lag])
        m1 += thetas[t1]
        m2 += thetas[t1+time_lag]
        t1 += 1
    return (auto_cov)/(t1) - (m1*m2)/(t1*t1)


def auto_correlation(thetas, time_lag):
    
    """
    
    calculating the auto-correlation of the stochastic processes of parameter theta

    Arguments
    ---------
    theta : the inputed value of the parameter theta generated by the stochastic process
    time_lag : the value of the time-lag of the of the auto-correlation

    Returns
    -------
    auto_corr : the auto-correlation value of the inputed parameters

    """

    return auto_covariance(thetas=thetas, time_lag=time_lag)/(np.std(thetas, axis=0)*np.std(thetas, axis=0))

def ESS(thetas):

    """
    
    Calculating the Effective Sample Size(ESS) of the inputed data 

    Arguments
    ---------
    thetas : the inputed value of the parameter theta generated by the stochastic precess

    Returns
    -------
    res : the Effective Sample Szie of inputed data
    
    """

    thetas =np.asarray(thetas)
    if len(thetas.shape)==1:
        thetas = np.expand_dims(thetas, axis=1)
    # Computing the autocorrelation function
    (m, n) = thetas.shape
    acf = np.asarray([auto_correlation(thetas=thetas, time_lag=t) for t in range(0, m)])
    # Computing the integrated autocorrelation tine
    iact = 1.0
    for t in range(1, len(acf)):
        for i in range(0, n):
            if acf[t, i]<0:
                acf[:, i] = 0
        iact += 2.0*acf[t]
    n = len(thetas)
    return n/iact

def auto_corr_plot(thetas, plot_nth_theta, theta_index, plot_together):
    """
    
    plot the auto-correlation of each time_lag

    Arguments
    ---------
    thetas (List[List[float]]): the value of the the parameters 
    plot_nth_theta (List[int]): the dimensions want to plot with the function
    theta_index (List[]): the indexes of different dimension parameters 
    plot_together (bool): deciding whether to plot all plots of auto-correlation together

    Returns
    -------
    None

    """

    thetas = np.asarray(thetas)
    if len(thetas.shape)==1:
        thetas = np.expand_dims(thetas,axis=1)
    (m, n) = thetas.shape # the data size of the inputed thetas and the dimension of the datas
    for i in plot_nth_theta:
        theta_i = thetas[:, i]
        acf = np.asarray([auto_correlation(thetas=theta_i, time_lag=t)[0] for t in range(0, m)])
        plt.plot(range(0, m), acf, label=f"The auto-correlation value of {theta_index[i]}")
        if not(plot_together):
            plt.legend()
            plt.xlabel("Time Lag Value")
            plt.ylabel("Auto-Correlation Value")
            plt.show()

    if plot_together:
        plt.legend()
        plt.xlabel("Time Lag Value")
        plt.ylabel("Auto-Correlation Value")
        plt.show()