import numpy as np

def auto_correlation(thetas, time_lag):
    
    """
    
    calculating the auto-correlation of the stochastic processes of parameter theta

    Arguments
    ---------
    theta : the inputed value of the parameter theta generated by the stochastic process
    time_lag : the value of the time-lag of the of the auto-correlation

    Returns
    -------
    auto_corr : the auto-correlation value of the inputed parameters

    """

    thetas = np.asarray(thetas)
    n = thetas.shape[0]
    if len((thetas.shape))==1:
        thetas = np.expand_dims(thetas, axis=1)
    auto_corr = np.zeros(thetas.shape[1])
    t1 = 0
    assert(t1+time_lag<=n-1)
    while(t1+time_lag<=n-1):
        auto_corr += (thetas[t1]*thetas[t1+time_lag])
        t1 += 1
    return auto_corr/t1
    
def auto_covariance(thetas, time_lag):

    """
    
    calculating the auto-covariance of the stochastic processes of the parameter theta

    Argumrnts
    ---------
    theta : the inputed value of the parameter theta generated by the stochastic process
    time_lag : the value of the time-lag of the of the auto-correlation

    Returns
    -------
    auto_cov : the auto-covariance value of the inputed parameters
    
    """

    thetas = np.asarray(thetas)
    n = thetas.shape[0]
    if len((thetas.shape))==1:
        thetas = np.expand_dims(thetas, axis=1)
    auto_cov, m1, m2= np.zeros(thetas.shape[1]), np.zeros(thetas.shape[1]), np.zeros(thetas.shape[1])
    t1 = 0
    assert(t1+time_lag<=n-1)
    while(t1+time_lag<=n-1):
        auto_cov += (thetas[t1]*thetas[t1+time_lag])
        m1 += thetas[t1]
        m2 += thetas[t1+time_lag]
        t1 += 1
    return (auto_cov)/(t1) - (m1*m2)/(t1*t1)

def ESS(thetas):

    """
    
    Calculating the Effective Sample Size(ESS) of the inputed data 

    Arguments
    ---------
    thetas : the inputed value of the parameter theta generated by the stochastic precess

    Returns
    -------
    res : the Effective Sample Szie of inputed data
    
    """

    thetas =np.asarray(thetas)
    if len(thetas.shape)==1:
        thetas = np.expand_dims(thetas, axis=1)
    # Computing the autocorrelation function
    (m, n) = thetas.shape
    acf = np.asarray([auto_correlation(thetas=(thetas-thetas.mean(axis=0)), time_lag=t) for t in range(0, m)])
    acf = acf/acf[0]
    # Computing the integrated autocorrelation tine
    iact = 1.0
    for t in range(1, len(acf)):
        for i in range(0, n):
            if acf[t, i]<0:
                acf[:, i] = 0
        iact += 2.0*acf[t]
    n = len(thetas)
    return n/iact
