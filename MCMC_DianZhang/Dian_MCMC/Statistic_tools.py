import numpy as np
import matplotlib.pyplot as plt
from typing import Callable, List
    

def auto_correlation(Thetas, time_lag):
    
    """
    
    calculating the auto-correlation of the stochastic processes of parameter theta

    Arguments
    ---------
    theta : the inputed value of the parameter theta generated by the stochastic process
    time_lag : the value of the time-lag of the of the auto-correlation

    Returns
    -------
    auto_corr : the auto-correlation value of the inputed parameters

    """

    Thetas = np.asarray(Thetas)
    if len((Thetas.shape))==1:
        Thetas = np.expand_dims(Thetas, axis=1)
    (m, n) = Thetas.shape
    thetas_stds_pro = (np.std(Thetas[0: m-time_lag], axis=0)*np.std(Thetas[time_lag: m], axis=0))
    auto_corr = []
    for i, thetai_stds_pro in enumerate(thetas_stds_pro):
        if thetai_stds_pro==0:
            auto_corr.append(0)
        else:
            theta1 = Thetas[0: m-time_lag, i]
            theta2 = Thetas[time_lag: m, i]
            auto_corr.append((np.mean(theta1*theta2) - np.mean(theta1)*np.mean(theta2))/thetai_stds_pro)
    return np.asarray(auto_corr)


def ESS(Thetas):

    """
    
    Calculating the Effective Sample Size(ESS) of the inputed data 

    Arguments
    ---------
    thetas : the inputed value of the parameter theta generated by the stochastic precess

    Returns
    -------
    res : the Effective Sample Szie of inputed data
    
    """

    Thetas =np.asarray(Thetas)
    if len(Thetas.shape)==1:
        Thetas = np.expand_dims(Thetas, axis=1)
    # Computing the autocorrelation function
    (m, n) = Thetas.shape
    acf = np.asarray([auto_correlation(Thetas=Thetas, time_lag=t) for t in range(0, m)])
    # Computing the integrated autocorrelation tine
    iact = 1.0
    for t in range(1, len(acf)):
        for i in range(0, n):
            if acf[t, i]<0:
                acf[:, i] = 0
        iact += 2.0*acf[t]
    return m/iact

def auto_corr_plot(Thetas, plot_nth_theta, theta_index, max_time_lag=None, data_range=[], plot_together=True, figsize=(10, 10)):
    """
    
    plot the auto-correlation of each time_lag

    Arguments
    ---------
    Thetas (List[List[float]]): the value of the the parameters
    plot_nth_theta (List[int]): the dimensions want to plot with the function
    theta_index (List[]): the indexes of different dimension parameters
    max_time_lag (int): the maximum time lag value to plot with the function
    data_range (List[int]) : the range of the data plotted by the function [t_min, t_max]
    plot_together (bool): deciding whether to plot all plots of auto-correlation together
    figsize : the figure size of the plots

    Returns
    -------
    None

    """

    Thetas = np.asarray(Thetas)
    if len(Thetas.shape)==1:
        Thetas = np.expand_dims(Thetas,axis=1)
    if not(data_range):
        data_range = [0, Thetas.shape[0]]
    if not(max_time_lag):
        max_time_lag = (data_range[1]-data_range[0])//30
    plt.rcParams["figure.figsize"] = figsize
    with plt.style.context("ggplot"):
        for i in plot_nth_theta:
            theta_i = Thetas[data_range[0]: data_range[1], i]
            m = theta_i.shape[0] # the data size of the plotted dataset
            acf = np.asarray([auto_correlation(Thetas=theta_i, time_lag=t)[0] for t in range(0, max_time_lag-1)])
            plt.plot(np.asarray(range(0, max_time_lag-1)), acf, label=f"The auto-correlation value of {theta_index[i]}")
            if not(plot_together):
                plt.legend()
                plt.xlabel("Time Lag Value")
                plt.ylabel("Auto-Correlation Value")
                plt.show()

        if plot_together:
            plt.legend()
            plt.xlabel("Time Lag Value")
            plt.ylabel("Auto-Correlation Value")
            plt.show()

def targetDis_step_plot(Thetas, rho: Callable, target_type: str, return_maximum=False, return_minimum=False, figsize=(6,8)):

    """
    
    Plotting the Target Distribution Value of each Step of iteration

    Arguments
    ---------
    thetas : the parameter/ datapoint values generated by the MCMC Algorithm
    rho (Callable): the target distribution of the parameter/ datapoint values generated by the MCMC Algorithm
    target_type (str): the type of the target distribution E.X. "pdf", "likelihood", "posterior"
    return_maximum (bool): deciding whether to output the maximum point
    return_minimum (bool): deciding whether to output the minimum point
    figsize : the figure size of the plots

    Returns
    -------
    None

    """

    datasize = len(Thetas)
    steps = list(range(datasize))
    target_vals = [rho(theta) for theta in Thetas]
    if return_maximum:
        max_step = np.argmax(target_vals)
    if return_minimum:
        min_step = np.argmin(target_vals)

    with plt.style.context("ggplot"):
        plt.rcParams["figure.figsize"] = figsize
        plt.plot(steps, target_vals, label="the "+target_type+" value of each step of iteration")
        if return_maximum:
            plt.scatter([max_step], [target_vals[max_step]], c="black", label=f"the {max_step}th step maximize the "+target_type, zorder=2)
        if return_minimum:
            plt.scatter([min_step], [target_vals[min_step]], c="blue", label=f"the {min_step}th step minimize the "+target_type, zorder=2)
        plt.legend(fontsize=min(figsize)*2)
        plt.xlabel("step")
        plt.ylabel(target_type)
        plt.show()

from matplotlib.patches import Rectangle

def densities_plot(Thetas, plot_axis, bins, cr_1D=0, mark_highest_density=False, figsize=(10, 9), cmap='viridis'):
    """
    Plot the density of each axis and the heat map of each pair of axis    

    Arguments
    ---------
    Thetas (np.array): the value of parameters generated by the MCMC model
    plot_axis (List[int]): the axis plotted by the function
    bins (int): the number of bins of each histogram and heat map
    cr_1D (float): the credible region of each 1D density histgram
    figsize: the figure size of the plots
    cmap: the color map used for the 2D histogram

    Returns
    -------
    None
    """

    if not(plot_axis):
        plot_axis = [i for i in range(Thetas.shape[1])]
    n_axis = len(plot_axis)
    datasize = Thetas.shape[0]
    CR_1D = {}

    with plt.style.context("ggplot"):

        fig, axes = plt.subplots(ncols=n_axis, nrows=n_axis, figsize=figsize)
        for i in range(0,n_axis):
            for j in range(0, i+1):
                if i==j:
                    cs, bs, patches = axes[i, j].hist(Thetas[:, plot_axis[i]], bins=bins)
                    axes[i, j].set_xlabel(f"$x_{plot_axis[i]}$")
                    axes[i, j].set_ylabel("Counts")
                    max_count_idx = np.argmax(cs)
                    bin_center = (bs[max_count_idx] + bs[max_count_idx+1]) / 2
                    if mark_highest_density:    
                        axes[i, j].plot([bin_center, bin_center], [0, cs[max_count_idx]], color='blue', linestyle='--')
                    axes[i, j].set_title("$argmax_{x}$(Counts)"+f" = {np.round(bin_center, 3)}", fontsize=10)
                    if cr_1D>0:
                        CR_1D[i] = []
                        posterior_prob = 0
                        posts = cs/datasize

                        while(posterior_prob<cr_1D):
                            max_pos_idx = np.argmax(posts)
                            posterior_prob += posts[max_pos_idx]
                            posts[max_pos_idx] = -1
                            CR_1D[i].append(bs[max_pos_idx:max_pos_idx+2])
                            patches[max_pos_idx].set_facecolor("steelblue")

                else:
                    hist = axes[i, j].hist2d(Thetas[:, plot_axis[i]], Thetas[:, plot_axis[j]], bins=bins, cmap=cmap)
                    axes[i, j].set_xlabel(f"$x_{plot_axis[i]}$")
                    axes[i, j].set_ylabel(f"$x_{plot_axis[j]}$")
                    fig.delaxes(axes[j, i])

        # Add colorbar to the whole plot
        cbar_ax = fig.add_axes([0.95, (1/n_axis)*1.1, 0.02, 1-(1/n_axis)*1.15]) # left, bottom, width, height
        fig.colorbar(hist[3], cax=cbar_ax)

        fig.subplots_adjust(right=0.85, wspace=0.3, hspace=0.3)
        fig.tight_layout()
        fig.legend(handles=[Rectangle((0,0),1,1,color="steelblue")], labels=[f"Credible Region = {cr_1D}"], loc="upper center")
    plt.show()
    return CR_1D