import numpy as np
import scipy.special as spc

class FakeDataGen2D_Poisson:
    def __init__(self, pdf, Data_range, bins, scaler=1):
        """

        The fake data generator

        Arguments
        ---------
        pdf (Callable): the probability density function
        Data_range (List[List[float]]): The range of the Fake data
        bins (int): the number of the bins
        
        """

        self.pdf = pdf
        self.scaler = scaler
        self.Data_range  = Data_range
        self.bins = bins
        # Generate a grid of x and y value
        x = np.linspace(Data_range[0][0], Data_range[0][1], bins)
        y = np.linspace(Data_range[1][0], Data_range[1][1], bins)
        self.x, self.y  = np.meshgrid(x, y)
        self.BinsValue = (self.pdf(np.column_stack((self.x.flatten(), self.y.flatten())))*((self.Data_range[0][1]-self.Data_range[0][0])*(self.Data_range[1][1]-self.Data_range[1][0])/(self.bins**2))*self.scaler)
        self.BinsValue = np.asanyarray([np.random.poisson(datai) for datai in self.BinsValue])

class LikeliFuncGen_ContinuousPoisson:
    def __init__(self, Data, pdf, Prior=None):

        """

        The Likelihood Function Generator

        Arguments
        ---------

        Data : the data set for the pdf function function
     
        Returns
        -------
        None

        """


        self.Data = Data
        self.pdf = pdf
        self.Prior = Prior
        if (self.Prior==None):
            def constantPrior(params):
                return 1
            self.Prior = constantPrior

    def Log_Likelihood(self, params):
        self.pdf.params = params
        self.lambda_theta = (self.pdf.f(np.column_stack((self.Data.x.flatten(), self.Data.y.flatten())))*((self.Data.Data_range[0][1]-self.Data.Data_range[0][0])*(self.Data.Data_range[1][1]-self.Data.Data_range[1][0])/(self.Data.bins**2))*self.Data.scaler)
        self.lambda_theta[self.lambda_theta==0] = 1e-8
        Valid_Range_1 = np.logical_and(self.Data.BinsValue>0, self.lambda_theta>0)
        Valid_Range_2 = np.logical_and(self.Data.BinsValue==0, self.lambda_theta>0)
        likeli = np.zeros(self.Data.BinsValue.shape)
        # likeli = (self.Data.BinsValue[Valid_Range]*np.log(self.lambda_theta[Valid_Range]) - self.lambda_theta[Valid_Range] - np.log(spc.factorial(self.Data.BinsValue[Valid_Range])))
        likeli[Valid_Range_1] = self.lambda_theta[Valid_Range_1] - self.Data.BinsValue[Valid_Range_1] + self.Data.BinsValue[Valid_Range_1]*np.log(self.Data.BinsValue[Valid_Range_1]/self.lambda_theta[Valid_Range_1])
        likeli[Valid_Range_2] = self.lambda_theta[Valid_Range_2]
        return -np.sum(likeli)
    
    def Likelihood(self, params):
        return np.exp(self.Log_Likelihood(params))
    
    def Posterior(self, params):

        """
        
        The Posterior Function

        Arguments
        ---------
        params : the parameter values of the probability denstiy function

        Returns
        -------
        (float)
        
        """
        
        return self.Likelihood(params)*self.Prior(params)

    def Log_Posterior(self, params):

        """
        
        The log(Posterior) Function

        Arguments
        ---------
        params : the parameter values of the probability denstiy function

        Returns
        -------
        (float)
        
        """

        return self.Log_Likelihood(params) + np.log(self.Prior(params))

def auto_correlation(Thetas, time_lag):
    
    """
    
    calculating the auto-correlation of the stochastic processes of parameter theta

    Arguments
    ---------
    theta : the inputed value of the parameter theta generated by the stochastic process
    time_lag : the value of the time-lag of the of the auto-correlation

    Returns
    -------
    auto_corr : the auto-correlation value of the inputed parameters

    """

    Thetas = np.asarray(Thetas)
    if len((Thetas.shape))==1:
        Thetas = np.expand_dims(Thetas, axis=1)
    (m, n) = Thetas.shape
    thetas_stds_pro = (np.std(Thetas[0: m-time_lag], axis=0)*np.std(Thetas[time_lag: m], axis=0))
    auto_corr = []
    for i, thetai_stds_pro in enumerate(thetas_stds_pro):
        if thetai_stds_pro==0:
            auto_corr.append(0)
        else:
            theta1 = Thetas[0: m-time_lag, i]
            theta2 = Thetas[time_lag: m, i]
            auto_corr.append((np.mean(theta1*theta2) - np.mean(theta1)*np.mean(theta2))/thetai_stds_pro)
    return np.asarray(auto_corr)

def Saving_Data(Data, FileName="MCMCoutput.npz"):
    np.savez(FileName, **Data)

def Loading_Data(FileName):
    return dict(np.load(FileName, allow_pickle=True))