from typing import List, Callable
import numpy as np
import matplotlib.pyplot as plt

class MHMC:  
    def __init__(
    self, 
    rho: Callable,
    seed=123
    ) -> None:
    
        """
        
        Metropolis Hasting Monte Carlo Algorithm
        
        Arguments
        ----------
        rho: the target distribution of the parameter
        seed: random seed of the distribution
        
        Returns
        -------
        None
        
        
        """
    
        # Setting the random seed of the numpy
        np.random.seed(seed)
        # Saving the inputed target distribution
        self.rho = rho

    def predict(
        self,
        theta0,
        qProb: Callable,
        qSamp: Callable,
        epoch: int,
        Output_all=False
    ) -> List[int]:
    
        """
        
        Predicting the value of the parameter, that maximize the target distribution
        
        Arguments
        ----------
        theta0: the initial value of the parameter
        qProb: probability of the proposal distribution of the parameter
        qSamp: draw the sample with the proposal distribution
        epoch: run the MCMC for n epoch
        Output_all: deciding whether to output all theta_n generated by Metropolis-Hasting Monte Carlo Markov Chain
        
        Returns
        -------
        theta_n: the prediction of the value of the parameter, that maximize the target distribution
        
        
        """
        
        if not(Output_all):
            self.theta_n = theta0
            for i in range(0, epoch):
                # Updating the parameter from the proposal disribution
                self.theta_nPlus1 = qSamp(self.theta_n)
                self.alpha = min(1, (self.rho(self.theta_nPlus1)*qProb(self.theta_nPlus1,self.theta_n))/(self.rho(self.theta_n)*qProb(self.theta_n,self.theta_nPlus1)))
                # Deciding whether to reject the update of the parameter
                self.u = np.random.default_rng().uniform(0, 1, 1)[0]
                if(self.alpha>=self.u):
                    self.theta_n = self.theta_nPlus1
                else:
                    pass
            return self.theta_n
        else:
            self.theta_n = theta0
            self.Theta = []
            for i in range(0, epoch):
                self.Theta.append(self.theta_n)
                # Updating the parameter from the proposal disribution
                self.theta_nPlus1 = qSamp(self.theta_n)
                self.alpha = min(1, (self.rho(self.theta_nPlus1)*qProb(self.theta_nPlus1,self.theta_n))/(self.rho(self.theta_n)*qProb(self.theta_n,self.theta_nPlus1)))
                # Deciding whether to reject the update of the parameter
                self.u = np.random.default_rng().uniform(0, 1, 1)[0]
                if(self.alpha>=self.u):
                    self.theta_n = self.theta_nPlus1
                else:
                    pass
            self.Theta.append(self.theta_n)
            return self.Theta
